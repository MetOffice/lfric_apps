!-----------------------------------------------------------------------------
! (C) Crown copyright 2025 Met Office. All rights reserved.
! The file LICENCE, distributed with this code, contains details of the terms
! under which the code may be used.
!-----------------------------------------------------------------------------
!
! The main entry point for calculating section 20 aviation diagnostics.
!
! Code Owner: Please refer to the UM file CodeOwners.txt
! This file currently belongs in section: physics_schemes_interface
! whilst discussions are ongoing about its final location.
!
MODULE aviation_diags_alg_mod

  USE constants_mod,              ONLY: r_def, i_def, l_def
  USE field_mod,                  ONLY: field_type
  USE field_collection_mod,       ONLY: field_collection_type
  USE io_config_mod,              ONLY: USE_xios_io
  USE initialise_diagnostics_mod, ONLY: init_diag => init_diagnostic_field

  USE lfric_xios_diag_mod,        ONLY: get_axis_dimension, get_axis_values
  USE log_mod,                    ONLY: log_event, log_scratch_space, &
                                        LOG_LEVEL_ALWAYS, LOG_LEVEL_ERROR, &
                                        LOG_LEVEL_INFO, LOG_LEVEL_DEBUG

  USE aviation_diags_kernel_mod,  ONLY: aviation_diags_kernel_type

  IMPLICIT NONE

PRIVATE
PUBLIC :: aviation_diags_alg, write_horizontal_divergence_diagnostic

CONTAINS

  ! Algorithm to calculate the section 20 aviation diagnostics.
  SUBROUTINE aviation_diags_alg(plev_geopot)

    IMPLICIT NONE

    ! Arguments

    ! We calculate the result from this input field.
    TYPE(field_type), INTENT(IN) :: plev_geopot
!    TYPE(field_collection_type), POINTER, INTENT(IN) :: prognostic_fields
!    TYPE(field_collection_type), POINTER, INTENT(IN) :: fd_fields


    ! Local variables

    ! These flags tell us which results are requested at this time step.
    LOGICAL(l_def) :: aviation_thick_850_flag, aviation_thick_500_flag

    ! The array of pressure levels.
    INTEGER(I_DEF) :: nplev
    REAL(R_DEF), ALLOCATABLE :: plevs(:)
    INTEGER(I_DEF) :: plevs_alloc_stat

    ! Level indices for the three pressure levels we want to read.
    INTEGER(I_DEF) :: i1000, i850, i500

    ! Approximate equality tolerance - is there a common variable somewhere?
    REAL(R_DEF), PARAMETER :: plev_tol = 0.1_r_def

    ! The two output fields we produce.
    TYPE( field_type ) :: aviation_thick_850, aviation_thick_500

    INTEGER(I_DEF) :: i


!    call wind_uv_divergence(prognostic_fields)
!    call wind_uv_divergence(fd_fields)


    ! Check the request flags.
    aviation_thick_850_flag = &
      init_diag(aviation_thick_850, 'aviation__geopot_thickness_850')
    aviation_thick_500_flag = &
      init_diag(aviation_thick_500, 'aviation__geopot_thickness_500')
    IF ( aviation_thick_850_flag .OR. aviation_thick_500_flag ) THEN
      WRITE(log_scratch_space, '(A)') 'Section 20 thickness is on'
      CALL log_event(log_scratch_space, LOG_LEVEL_DEBUG)
    ELSE
      ! Nothing requested at this time step.
      RETURN
    END IF

    ! Get the array of pressure levels.
    nplev = get_axis_dimension('pressure_levels')
    IF (nplev <= 0) THEN
      WRITE(log_scratch_space, '(A, I0)') 'No pressure levels, nplev=', nplev
      CALL log_event(log_scratch_space, LOG_LEVEL_ERROR)
      RETURN
    END IF

    ALLOCATE(plevs(nplev), stat=plevs_alloc_stat)
    IF (plevs_alloc_stat /= 0) THEN
      WRITE(log_scratch_space, '(A, I0)') 'allocate(plevs) failed, stat=', &
        plevs_alloc_stat
      CALL log_event(log_scratch_space, LOG_LEVEL_ERROR)
      RETURN
    END IF
    plevs = get_axis_values('pressure_levels',nplev)

    ! Find the level indices for our three pressures of interest.
    ! Leave as -1 if not requested, telling the kernel not to calculate it.
    ! Assumes hPa. Should we worry about other units?
    i1000 = -1
    i850  = -1
    i500  = -1
    DO i = 1, nplev

      ! 1000?
      IF ( abs(plevs(i) - 100000.0_r_def) < plev_tol ) THEN
        i1000 = i

      ! 850?
      ELSE IF ( abs(plevs(i) - 85000.0_r_def) < plev_tol ) THEN
        i850 = i

      ! 500?
      ELSE IF ( abs(plevs(i) - 50000.0_r_def) < plev_tol ) THEN
        i500 = i

      END IF
    END DO

    ! Check we found the required levels.
    IF (i1000 == -1) THEN
        WRITE(log_scratch_space, '(A)') 'could not find 1000hPa'
        CALL log_event(log_scratch_space, LOG_LEVEL_ERROR)
        RETURN
    END IF

    IF (aviation_thick_850_flag .AND. i850 == -1) THEN
      WRITE(log_scratch_space, '(A)') 'could not find 850hPa'
      CALL log_event(log_scratch_space, LOG_LEVEL_ERROR)
      RETURN
    END IF

    IF (aviation_thick_500_flag .AND. i500 == -1) THEN
      WRITE(log_scratch_space, '(A)') 'could not find 500hPa'
      CALL log_event(log_scratch_space, LOG_LEVEL_ERROR)
      RETURN
    END IF

    ! Call the kernel to subtract the levels.
    ! Todo: Comment why we initialise to 1.0 and not 0.0. I can't remember.
    CALL invoke( &
      setval_c(aviation_thick_850, 1.0_r_def), &
      setval_c(aviation_thick_500, 1.0_r_def), &
      aviation_diags_kernel_type(&
        aviation_thick_850, aviation_thick_500, &
        plev_geopot, &
        aviation_thick_850_flag, aviation_thick_500_flag, &
        i1000, i850, i500) &
    )

    ! Write the fields
    IF (aviation_thick_850_flag) CALL aviation_thick_850%write_field()
    IF (aviation_thick_500_flag) CALL aviation_thick_500%write_field()

    ! Clean up.
    IF (allocated(plevs)) THEN
      DEALLOCATE(plevs)
    END IF

  END SUBROUTINE aviation_diags_alg


!#ifdef NOT_LIKE_THIS
!  SUBROUTINE wind_uv_divergence(prognostic_fields)
!!  SUBROUTINE wind_uv_divergence(fd_fields)
!
!    USE dg_matrix_vector_kernel_mod,    ONLY: dg_matrix_vector_kernel_type
!    USE r_tran_field_mod,               ONLY: r_tran_field_type
!    USE r_tran_operator_mod,            ONLY: r_tran_operator_type
!    USE transport_enumerated_types_mod, ONLY: direction_h
!    USE transport_constants_mod,        ONLY: get_directional_im3_div_r_tran
!
!    IMPLICIT NONE
!
!    TYPE( field_collection_type ), POINTER, INTENT(IN) :: prognostic_fields
!!    TYPE( field_collection_type ), POINTER, INTENT(IN) :: fd_fields
!
!    ! single horizontal uv wind field
!    TYPE( field_type ), POINTER :: wind_3d => null()
!!    TYPE( field_type ), POINTER :: h_wind_in_w2h => null()
!
!    ! div operator for direction_h
!    TYPE(r_tran_operator_type), POINTER :: div_op
!
!    ! result divergence field
!    TYPE(r_tran_field_type) :: uv_div
!
!    LOGICAL(l_def) :: uv_div_flag
!
!
!    ! requested for this time step?
!    uv_div_flag = init_diag(uv_div, 'aviation__uv_wind_divergence')
!    IF (.not. uv_div_flag) THEN
!      return
!    END IF
!
!
!    ! get the wind field
!    ! todo: make sure this is available
!    CALL prognostic_fields%get_field('wind', wind_3d)
!
!    ! get the horizontal div operator matrix for this mesh
!    div_op => get_directional_im3_div_r_tran(wind_3d%get_mesh_id(), direction_h)
!
!    ! multiply the wind by the div operator matrix to get the div
!    CALL invoke(dg_matrix_vector_kernel_type(uv_div, wind_3d, div_op))
!
!    ! save it
!    CALL uv_div%write_field()
!
!
!
!!    ! get the wind field
!!    CALL fd_fields%get_field('h_wind', h_wind_in_w2h)
!!
!!    ! get the horizontal div operator matrix for this mesh
!!    div_op => get_directional_im3_div_r_tran(wind%get_mesh_id(), direction_h)
!!
!!    ! multiply the wind by the div operator matrix to get the div
!!    CALL invoke(dg_matrix_vector_kernel_type(div, wind, div_op))
!!
!!    ! save it
!!    CALL div%write_field()
!
!
!
!
!
!!    ! wind u and v fields
!!    TYPE( field_type ), POINTER :: u_wind => null()
!!    TYPE( field_type ), POINTER :: v_wind => null()
!!
!!    ! div operator for each direction (todo: do we only need one?)
!!    TYPE(r_tran_operator_type), POINTER :: u_div_op
!!    TYPE(r_tran_operator_type), POINTER :: v_div_op
!!
!!    ! result u and v divergence fields
!!    TYPE(r_tran_field_type) :: u_div, v_div
!!!    TYPE(field_type) :: u_div, v_div
!!    TYPE(field_type) :: uv_div
!!
!!    LOGICAL(l_def) :: uv_div_flag
!!
!!
!!    ! requested for this time step?
!!    uv_div_flag = init_diag(uv_div, 'aviation__uv_wind_divergence')
!!    IF (.not. uv_div_flag) THEN
!!      return
!!    END IF
!!
!!
!!    ! get the u and v wind fields
!!    CALL prognostic_fields%get_field('u', u_wind)
!!    CALL prognostic_fields%get_field('v', v_wind)
!!
!!    ! get and apply the horizontal div operator for this mesh, for u
!!    u_div_op => get_directional_im3_div_r_tran(u_wind%get_mesh_id(), direction_h)
!!    CALL invoke(dg_matrix_vector_kernel_type(u_div, u_wind, u_div_op))
!!
!!    ! and for v
!!    v_div_op => get_directional_im3_div_r_tran(v_wind%get_mesh_id(), direction_h)
!!    CALL invoke(dg_matrix_vector_kernel_type(v_div, v_wind, v_div_op))
!!
!!    ! add v to u and save it(?)
!!    CALL invoke(X_plus_Y(uv_div, u_div, v_div))
!!    CALL uv_div%write_field()
!
!
!  END SUBROUTINE wind_uv_divergence
!#endif


  !-------------------------------------------------------------------------------
  !>  @brief    Handles divergence diagnostic processing
  !!
  !!  @details  Handles divergence diagnostic processing
  !!
  !!> @param[in] u_field     The u field
  !!> @param[in] ts          Timestep
  !!> @param[in] mesh        Mesh
  !-------------------------------------------------------------------------------
  ! TODO: where should this live?
!  subroutine write_horizontal_divergence_diagnostic( &
!          wind_3d, clock, mesh, element_order_h, element_order_v)
!  subroutine write_horizontal_divergence_diagnostic( &
!          wind_3d, clock, element_order_h, element_order_v)
  subroutine write_horizontal_divergence_diagnostic( &
          wind, clock, main_mesh, element_order_h, element_order_v)
    use fs_continuity_mod,              only: W2H, W2v, W3
    use function_space_collection_mod,  only: function_space_collection
    use model_clock_mod,                only: model_clock_type

    use sci_geometric_constants_mod,    only: &
      get_coordinates, get_face_selector_ew, get_face_selector_ns, &
      get_panel_id

    use split_w2_field_kernel_mod,      only: split_w2_field_kernel_type
    use transport_constants_mod,        only: get_directional_im3_div_r_tran
    use transport_enumerated_types_mod, only: direction_h
    use r_tran_operator_mod,            only: r_tran_operator_type

    use dg_matrix_vector_kernel_mod,    only: dg_matrix_vector_kernel_type

    use mesh_mod,                       only: mesh_type
    use integer_field_mod,              only: integer_field_type
    use initialise_diagnostics_mod,     only : diagnostic_to_be_sampled

    use field_parent_mod,               only: write_interface
    use lfric_xios_write_mod,           only: write_field_generic

    use diagnostics_io_mod,             only : write_scalar_diagnostic
    use sci_project_output_mod,         only: project_output


    implicit none

!    type(field_type),        intent(in)          :: wind_3d
    type(field_type),        intent(in)          :: wind
    class(model_clock_type), intent(in)          :: clock
    type(mesh_type),         intent(in), pointer :: main_mesh

    integer(kind=i_def), intent(in) :: element_order_h, element_order_v

    type(mesh_type), pointer                     :: p_div_mesh => null()

    type(field_type)                     :: wind_h, wind_v
    type(field_type)                     :: div_ml, div_ml_h, div_ml_v
    type(field_type)                     :: div_pl(1)
!    type(field_type)                     :: div_pl1
    type(field_type), pointer            :: chi(:)
    type(r_tran_operator_type), pointer  :: div_op
    type(field_type), pointer            :: panel_id
!    integer(kind=i_def)                  :: element_order_h, element_order_v

    type(integer_field_type), pointer :: face_selector_ew => null()
    type(integer_field_type), pointer :: face_selector_ns => null()

    procedure(write_interface), pointer  :: tmp_write_ptr


    if (.not. diagnostic_to_be_sampled('aviation__uv_wind_divergence')) then
      return
    endif



      ! Create the divergence diagnostic
!      call divergence_diagnostic_alg( div_field, l2_norm, wind_3d, mesh )




!    ! todo: initialise div_ml with the same function space as the wind(?)
!    function_space_collection%get_fs( &
!      mesh, element_order_h, element_order_v, <function_space>)





    ! get the horizontal div operator matrix for this mesh
!    div_op => get_directional_im3_div(wind%get_mesh_id(), direction_h)
    div_op => get_directional_im3_div_r_tran(wind%get_mesh_id(), direction_h)


    ! Split the 3d wind into horizontal and vertical components
    face_selector_ew => get_face_selector_ew(wind%get_mesh_id())
    face_selector_ns => get_face_selector_ns(wind%get_mesh_id())

    call wind_h%initialise( function_space_collection%get_fs( &
        main_mesh, element_order_h, element_order_v, W2h ))
    call wind_v%initialise( function_space_collection%get_fs( &
        main_mesh, element_order_h, element_order_v, W2v ))

    call invoke( split_w2_field_kernel_type( &
        wind_h, wind_v, wind, face_selector_ew, face_selector_ns ))


    ! what function space should div_ml be on?
    call div_ml%initialise( function_space_collection%get_fs( &
        main_mesh, element_order_h, element_order_v, W3 ))


    ! multiply the wind by the div operator matrix to get the div
    CALL invoke(dg_matrix_vector_kernel_type(div_ml, wind_h, div_op))


    ! Project the field to the output field
    ! which mesh should we use? this or the one passed in?

!    mesh     => div_ml%get_mesh()
!    chi      => get_coordinates( mesh%get_id() )
!    panel_id => get_panel_id( mesh%get_id() )

    p_div_mesh     => div_ml%get_mesh()
    chi      => get_coordinates( p_div_mesh%get_id() )
    panel_id => get_panel_id( p_div_mesh%get_id() )

    call project_output( div_ml, div_pl, chi, panel_id, W3 )
!    div_pl1 = div_pl(1)




    if (use_xios_io) then
      !If using XIOS, we need to set a field I/O method appropriately
      tmp_write_ptr => write_field_generic
      call div_pl(1) % set_write_behaviour(tmp_write_ptr)
    end if

!    call write_scalar_diagnostic( 'divergence', div_pl1, clock, mesh, .false. )
    call write_scalar_diagnostic( &
        'divergence', div_pl(1), clock, p_div_mesh, .false. )

    nullify(tmp_write_ptr)


  end subroutine write_horizontal_divergence_diagnostic



END MODULE aviation_diags_alg_mod
